以下是将所有 Nekro Agent 插件开发文档合并为一个完整的 Markdown 文件：

```markdown
---
title: Nekro Agent 插件开发完整指南
description: 从入门到精通，全面掌握 Nekro Agent 插件开发的核心概念、高级功能和系统 API。
---

# Nekro Agent 插件开发完整指南

## 引言

欢迎来到 Nekro Agent 插件开发的世界！本指南将引导你从零开始学习如何为 Nekro Agent 创建强大且富有创意的插件。

### 什么是 Nekro Agent 插件？

Nekro Agent 插件是一种扩展 Nekro Agent核心功能的方式。通过插件，开发者可以为 Agent 添加新的工具、信息源、交互逻辑，甚至与其他服务和系统集成。插件使得 Nekro Agent 能够适应更广泛的应用场景，满足更个性化的需求。

每个插件都是一个独立的 Python 模块，通过 Nekro Agent 提供的 API 与核心系统进行交互。

### 插件能做什么？

Nekro Agent 插件几乎可以实现任何你希望 Agent 完成的任务，例如：

*   **增强 AI 能力**：
    *   提供专业领域的知识库查询。
    *   执行复杂的数学计算或数据分析。
    *   集成第三方 API（如天气查询、新闻聚合、翻译服务等）。
*   **执行具体动作**：
    *   发送消息、邮件或通知。
    *   管理定时任务和提醒。
    *   控制智能家居设备。
*   **与外部系统交互**：
    *   创建强大的 Web API 接入点，支持完整的 RESTful 设计。
    *   与其他应用程序或服务进行数据同步。
    *   处理文件传输和多媒体内容交互。
*   **个性化用户体验**：
    *   根据用户偏好提供定制化内容。
    *   实现独特的人机交互方式。
    *   利用向量数据库提供智能语义搜索功能。

插件的类型多种多样，从简单的工具调用到复杂的业务逻辑处理，你可以充分发挥想象力。

### 插件系统架构概览

Nekro Agent 插件系统基于模块化和事件驱动的架构设计：

1.  **插件注册**：每个插件通过 `NekroPlugin` 类进行定义和注册，声明其元信息和功能。
2.  **沙盒执行与 RPC**：AI 生成的指令（通常是 Python 代码片段）会在一个隔离的沙盒环境中执行。当这些指令需要调用插件提供的功能时，会通过 RPC (远程过程调用) 机制调用在主服务进程中运行的插件方法。插件方法的执行结果会返回给沙盒，供 AI 后续处理。
3.  **API 交互**：插件通过 Nekro Agent 提供的丰富 API 与核心服务（如消息发送、数据存储、上下文管理等）进行交互。
4.  **事件驱动**：插件可以监听并响应系统中的各种事件，如消息接收、会话重置等。
5.  **配置与存储**：插件可以定义自己的配置项，方便用户管理，并拥有独立的存储空间来持久化数据。
6.  **高级功能**：
    *   **动态路由**：基于 FastAPI 创建强大的 Web API 端点，支持完整的 RESTful 功能。
    *   **文件系统**：通过 `AgentCtx.fs` 实现插件与 AI 沙盒之间的高效文件传递。
    *   **向量数据库**：集成 Qdrant 向量数据库，为插件提供语义搜索和智能检索能力。
    *   **上下文管理**：通过 `AgentCtx` 统一访问聊天信息、消息服务、配置和适配器功能。

这种设计确保了插件运行的灵活性和安全性，同时为开发者提供了强大的扩展能力。

### 阅读本指南的前提条件

为了更好地理解和学习本指南，建议你具备以下基础：

*   **Python 编程基础**：熟悉 Python 语法、异步编程 (`async/await`) 和面向对象编程。
*   **了解 API 概念**：理解什么是 API 以及如何使用它们。
*   **Nekro Agent 基本使用**：对 Nekro Agent 的基本功能和操作有一定了解。

## 快速上手

本章节将引导你快速搭建插件开发环境，并创建你的第一个 Nekro Agent 插件。

### 开发环境准备

在开始之前，请确保你已经安装并成功运行了 Nekro Agent。插件开发通常在 Nekro Agent 项目的 `plugins/workdir/` 目录下进行。

你需要：

1.  **Python 环境**：与 Nekro Agent 主程序兼容的 Python 版本（通常为 Python 3.10+）。
2.  **Nekro Agent 源码或已安装实例**：方便查看核心代码和 API 定义。
3.  **代码编辑器**：如 VSCode、PyCharm 等，用于编写插件代码。

### 创建你的第一个插件: "Hello Plugin"

让我们创建一个简单的插件，它会提供一个沙盒方法，当被调用时返回 "Hello from Plugin!"。

#### 1. 创建插件目录和文件

在 Nekro Agent 的插件工作目录（通常是 `plugins/workdir/`）下，创建一个新的插件目录，例如 `hello_plugin`。

```
plugins/
└── workdir/
    └── hello_plugin/
        ├── __init__.py
        └── plugin.py
```

*   `__init__.py`: 这个文件**至关重要**。它使得 `hello_plugin` 目录可以被 Python 视为一个包。更重要的是，Nekro Agent 的插件加载机制通常会从这个 `__init__.py` 文件中查找并导入 `NekroPlugin` 的实例。如果你的 `NekroPlugin` 实例（通常命名为 `plugin`）定义在同目录下的 `plugin.py` 文件中，那么 `__init__.py` **必须**从 `plugin.py` 导入并导出该实例。其内容应如下：
    ```python
    # hello_plugin/__init__.py
    from .plugin import plugin

    # 可选，但推荐，用于明确导出的接口
    __all__ = ["plugin"]
    ```
*   `plugin.py`: 这是我们插件的核心代码文件，其中定义了 `NekroPlugin` 实例以及相关的沙盒方法、配置等。

#### 2. 编写插件核心代码 (`plugin.py`)

打开 `hello_plugin/plugin.py` 文件，并输入以下内容：

```python
from nekro_agent.api.plugin import NekroPlugin, SandboxMethodType
from nekro_agent.api.schemas import AgentCtx

# 1. 创建插件实例
plugin = NekroPlugin(
    name="你好插件",  # 插件在 UI 中显示的名称
    module_name="hello_plugin",  # 插件的模块名，应与目录名一致且唯一
    description="一个简单的 Hello World 插件示例。",
    author="你的名字",
    version="0.1.0",
    url="https://your.plugin.repo.url" # 可选，插件的仓库或主页地址
)

# 2. 注册一个沙盒方法
@plugin.mount_sandbox_method(
    method_type=SandboxMethodType.TOOL, # 方法类型为 TOOL，结果直接返回给 AI
    name="say_hello",                  
    description="返回一个问候语。"       
)
async def say_hello_from_plugin(_ctx: AgentCtx) -> str:
    """插件的问候方法

    不需要任何参数，直接返回一个固定的问候字符串。

    Returns:
        str: "Hello from Plugin!"
    """
    return "Hello from Plugin!"

# 你可以在这里添加更多的插件逻辑，如配置、初始化方法等
```

**代码解释**：

*   **`from nekro_agent.api.plugin import NekroPlugin, SandboxMethodType`**: 导入了创建插件实例和定义沙盒方法类型所需的核心类。
*   **`from nekro_agent.api.schemas import AgentCtx`**: 导入了 `AgentCtx`，它是沙盒方法和许多其他插件回调函数的标准上下文参数，包含了会话信息等。
*   **`plugin = NekroPlugin(...)`**: 创建了一个 `NekroPlugin` 类的实例。你需要提供插件的名称、模块名、描述等基本信息。
    *   `name`: 用户在界面上看到的插件名称。
    *   `module_name`: 插件的唯一标识符，通常与你的插件目录名一致。
    *   `author`: 插件作者名。
*   **`@plugin.mount_sandbox_method(...)`**: 这是一个装饰器，用于将一个函数注册为插件的沙盒方法。AI 可以通过沙盒环境调用这些方法。
    *   `method_type=SandboxMethodType.TOOL`: 指定了这个方法是一个"工具"类型的方法。这类方法的返回值会直接提供给 AI 使用。
*   **`async def say_hello_from_plugin(_ctx: AgentCtx) -> str:`**: 定义了沙盒方法的实际执行逻辑。
    *   它是一个异步函数 (`async def`)。
    *   第一个参数必须是 `_ctx: AgentCtx`。
    *   类型注解 `-> str` 表明它返回一个字符串。
    *   文档字符串 (docstring) 详细描述了方法的功能、参数和返回值，这对于 AI 正确使用该方法至关重要。

#### 3. 加载和测试插件

1.  **启动/重启 Nekro Agent**：
    如果你是在 `plugins/workdir/` 目录下创建的插件，Nekro Agent 在启动时通常会自动扫描并加载该目录下的所有插件。
    如果 Agent 已经在运行，你可能需要重启 Agent 或通过其管理界面重新加载插件。

2.  **在 Agent 中测试**：
    加载成功后，你就可以在与 Nekro Agent 的对话中尝试调用这个插件方法了。例如，你可以对 Agent 说：
    `"调用 say_hello_from_plugin 方法"`
    或者更自然地：
    `"让 hello_plugin 说你好"`

    Agent 的 AI 模型会根据你的指令，结合函数中的文档字符串，决定是否以及如何调用 `say_hello_from_plugin` 方法。如果调用成功，AI 应该会告诉你插件返回了 "Hello from Plugin!"。

    你也可以通过指令调用代码：
    ```python
    /exec say_hello_from_plugin()
    ```
    发送指令前确保机器人也处在同一会话内

恭喜！你已经成功创建并测试了你的第一个 Nekro Agent 插件。

## 插件核心概念

在上一章节中，你已经成功创建并运行了一个简单的插件。本章节将带你深入了解构成 Nekro Agent 插件的各个核心概念。掌握这些概念是开发更复杂、功能更强大插件的基础。

### 插件实例与生命周期

每个 Nekro Agent 插件的核心都是一个 `NekroPlugin` 类的实例。这个实例不仅定义了插件的基本信息，还作为各种功能和事件回调的挂载点。理解插件实例的创建和其完整的生命周期对于开发稳定且功能完善的插件至关重要。

#### `NekroPlugin` 实例

在你的插件主文件 (例如 `plugin.py`) 中，首先需要导入并创建一个 `NekroPlugin` 实例：

```python
from nekro_agent.api.plugin import NekroPlugin

plugin = NekroPlugin(
    name="我的酷炫插件",
    module_name="my_cool_plugin",
    description="这个插件能做很多酷炫的事情。",
    version="1.0.0",
    author="开发者名称",
    url="https://github.com/developer/my_cool_plugin",
    support_adapter=["onebot_v11", "telegram"],  # 可选，支持的适配器列表
    is_builtin=False,  # 通常第三方插件为 False
    is_package=False   # 如果你的插件是一个复杂的包结构，可能需要调整
)
```

**核心参数解析**：

- `name` (str): 插件的显示名称，将出现在 Nekro Agent 的用户界面中。
- `module_name` (str): 插件的模块名称，必须是 Python 模块的有效名称，并且在所有插件中保持唯一。通常与插件的目录名一致。它用于内部识别和管理插件。
- `description` (str): 插件的简短描述，说明其主要功能。
- `version` (str): 插件的版本号，建议遵循语义化版本规范 (如 `1.0.0`)。
- `author` (str): 插件的作者或开发团队名称，必须由英文字母、数字、下划线组成，且不能以数字开头。
- `url` (str): 指向插件项目仓库、文档或主页的 URL。
- `support_adapter` (List[str], 可选): 插件支持的适配器列表，如 `["onebot_v11", "telegram"]`。如果未指定，则默认支持所有适配器。
- `is_builtin` (bool, 可选, 默认为 `False`): 标记插件是否为 Nekro Agent 内置插件。
- `is_package` (bool, 可选, 默认为 `False`): 标记插件是否作为一个 Python 包进行管理。

`NekroPlugin` 实例 (`plugin`) 将作为后续所有装饰器的调用对象，用于挂载沙盒方法、配置、生命周期回调等。

#### 插件生命周期

插件的生命周期描述了从插件被系统发现、加载、运行到最终卸载的整个过程。Nekro Agent 提供了一系列装饰器，允许你在生命周期的特定阶段执行自定义逻辑。

##### 1. 初始化 (`@plugin.mount_init_method()`)

当 Nekro Agent 首次加载插件时（通常在 Agent 启动或插件被动态启用时），会执行通过 `@plugin.mount_init_method()` 装饰器注册的异步函数。这个阶段非常适合执行只需要进行一次的设置工作。

**用途**：

- **资源准备**：创建或连接数据库、初始化文件系统（如创建插件所需的数据目录）。
- **状态初始化**：设置插件的初始状态、加载默认配置或数据。
- **外部系统连接**：如果插件需要与外部服务交互，可以在此建立连接。
- **环境验证**：检查必要的依赖项或环境变量是否满足。

**示例**：

```python
from nekro_agent.api import core
from qdrant_client import models as qdrant_models

@plugin.mount_init_method()
async def initialize_plugin():
    core.logger.info(f"插件 '{plugin.name}' 正在初始化...")
    # 示例：初始化向量数据库集合
    try:
        client = await core.get_qdrant_client()
        collection_name = plugin.get_vector_collection_name("my_data")

        collections = await client.get_collections()
        collection_names = [collection.name for collection in collections.collections]

        if collection_name not in collection_names:
            core.logger.info(f"正在创建向量数据库集合: {collection_name}")
            await client.create_collection(
                collection_name=collection_name,
                vectors_config=qdrant_models.VectorParams(
                    size=768,
                    distance=qdrant_models.Distance.COSINE,
                ),
            )
            core.logger.success(f"集合 {collection_name} 创建成功")
        else:
            core.logger.info(f"集合 {collection_name} 已存在")
    except Exception as e:
        core.logger.error(f"插件 '{plugin.name}' 初始化向量数据库失败: {e}")
    core.logger.success(f"插件 '{plugin.name}' 初始化完成。")
```

##### 2. 会话重置回调 (`@plugin.mount_on_channel_reset()`)

当一个特定的聊天会话被重置时（例如用户清空了聊天历史或会话状态），通过 `@plugin.mount_on_channel_reset()` 装饰器注册的异步函数会被调用。

**用途**：

- 清理与特定会话相关的插件数据（如缓存、状态）。
- 重置该会话的插件特定设置。

**示例**：

```python
from nekro_agent.api.schemas import AgentCtx

@plugin.mount_on_channel_reset()
async def handle_channel_reset(_ctx: AgentCtx):
    core.logger.info(f"插件 '{plugin.name}' 收到会话 {_ctx.from_chat_key} 重置事件。")
    # 清除该会话的插件特定缓存
    await plugin.store.delete(chat_key=_ctx.from_chat_key, store_key="session_cache")
    core.logger.info(f"会话 {_ctx.from_chat_key} 的插件特定数据已清理。")
```

##### 3. 用户消息回调 (`@plugin.mount_on_user_message()`)

当用户发送消息时，通过 `@plugin.mount_on_user_message()` 装饰器注册的异步函数会被调用。

**用途**：

- **消息预处理**：在 AI 处理之前对用户消息进行处理、过滤或增强。
- **权限控制**：根据用户身份或消息内容进行访问控制。
- **消息统计**：记录用户的消息使用情况或行为分析。
- **自动回复**：对特定类型的消息提供即时响应。

**示例**：

```python
from nekro_agent.api.message import ChatMessage
from nekro_agent.api.signal import MsgSignal

@plugin.mount_on_user_message()
async def handle_user_message(_ctx: AgentCtx, message: ChatMessage) -> MsgSignal | None:
    """处理用户消息的回调函数"""

    # 示例：消息内容过滤
    if "禁止词" in message.content_text:
        core.logger.warning(f"用户 {_ctx.from_user_id} 发送了包含禁止词的消息")
        return MsgSignal.BLOCK_ALL  # 阻止消息被记录到历史并阻止后续处理

    # 示例：特殊命令处理
    if message.content_text.startswith("!plugin:"):
        command = message.content_text[8:].strip()
        await _ctx.send_text(f"收到插件命令: {command}")
        return MsgSignal.BLOCK_TRIGGER  # 允许消息被记录但阻止触发AI处理

    # 返回 None 表示消息正常处理
    return None
```

##### 4. 系统消息回调 (`@plugin.mount_on_system_message()`)

当系统发送消息时（如管理员命令、系统通知等），通过 `@plugin.mount_on_system_message()` 装饰器注册的异步函数会被调用。

**用途**：

- **系统事件监听**：监听系统级别的消息和事件。
- **管理功能集成**：响应管理员命令或系统状态变化。
- **日志记录**：记录重要的系统消息。

##### 5. 提示词注入 (`@plugin.mount_prompt_inject_method()`)

提示词注入允许插件在 AI 处理用户消息之前，向系统提示词中动态添加内容。

**用途**：

- **上下文增强**：为 AI 提供当前会话的状态信息、用户偏好等。
- **角色定义**：为 AI 设定特定的角色或行为模式。
- **功能提示**：为 AI 提供更详细的插件使用指导说明。

**示例**：

```python
@plugin.mount_prompt_inject_method(
    name="user_preference_injection",
    description="向 AI 注入用户偏好和状态信息"
)
async def inject_user_context(_ctx: AgentCtx) -> str:
    """注入用户上下文信息到 AI 提示词中"""

    # 获取用户偏好
    user_preferences = await plugin.store.get(
        user_key=_ctx.from_user_id,
        store_key="preferences"
    )

    # 获取会话状态
    session_mode = await plugin.store.get(
        chat_key=_ctx.from_chat_key,
        store_key="mode"
    )

    prompt_parts = []

    if user_preferences:
        prompt_parts.append(f"用户偏好设置：{user_preferences}")

    if session_mode:
        prompt_parts.append(f"当前会话模式：{session_mode}")

    return "\n".join(prompt_parts)
```

##### 6. 清理 (`@plugin.mount_cleanup_method()`)

当插件被卸载或 Nekro Agent 关闭时，会执行通过 `@plugin.mount_cleanup_method()` 装饰器注册的异步函数。

**用途**：

- **释放资源**：关闭数据库连接、释放文件句柄、停止后台任务等。
- **重置状态**：清空全局变量或缓存，确保下次加载时是全新的状态。
- **外部系统断开连接**：如果插件与外部服务保持长连接，应在此处断开。

**示例**：

```python
@plugin.mount_cleanup_method()
async def cleanup_plugin():
    core.logger.info(f"插件 '{plugin.name}' 正在清理...")
    # 示例：关闭可能存在的数据库连接池或清除临时文件
    core.logger.success(f"插件 '{plugin.name}' 清理完成。")
```

### 沙盒方法详解

沙盒方法是 Nekro Agent 插件向 AI 提供功能和交互能力的主要途径。AI 在其沙盒环境中执行代码时，可以通过调用这些方法来获取信息、执行操作或请求进一步的处理。

#### 什么是沙盒方法？

当 AI 需要执行某些超出其自身能力范围的操作时（例如，访问外部 API、读写文件、执行复杂计算），它会生成一段代码，这段代码通常会调用插件提供的特定函数。这些被插件暴露给 AI 调用的函数，我们就称之为"沙盒方法"。

**核心特点：RPC 执行机制**

一个非常重要的概念是，尽管这些方法被 AI 在"沙盒"环境中调用，但它们的**实际执行发生在 Nekro Agent 的主服务进程中**，而不是在隔离的沙盒内。这种通信是通过 RPC（远程过程调用）实现的。

*   AI 在沙盒中发起调用请求。
*   Nekro Agent 核心系统接收请求，并在主进程中找到并执行对应的插件沙盒方法。
*   方法的执行结果通过 RPC 返回给沙盒环境，供 AI 后续使用。

#### 注册沙盒方法

沙盒方法通过 `@plugin.mount_sandbox_method()` 装饰器注册到插件实例上。

```python
from nekro_agent.api.plugin import SandboxMethodType
from nekro_agent.api.schemas import AgentCtx

@plugin.mount_sandbox_method(
    method_type=SandboxMethodType.TOOL,
    name="calculate_sum",
    description="计算两个数字的和。"
)
async def my_sum_function(_ctx: AgentCtx, num1: int, num2: int) -> int:
    """计算并返回两个整数的和。

    Args:
        num1 (int): 第一个加数。
        num2 (int): 第二个加数。

    Returns:
        int: 两个数字的和。
    """
    return num1 + num2
```

**装饰器参数**：

*   `method_type` (SandboxMethodType): 指定沙盒方法的类型，这决定了 AI 如何使用该方法以及框架如何处理其返回值。
*   `name` (str): 用于在前端展示给用户的方法名称。
*   `description` (str): 对该方法的详细描述，将在前端展示给用户。

#### 沙盒方法类型 (`SandboxMethodType`)

`SandboxMethodType` 是一个枚举类型，定义了沙盒方法的不同行为模式。

##### 1. `SandboxMethodType.TOOL` (工具方法)

*   **用途**：提供特定的、可直接使用的工具或功能，AI 调用后可以直接利用其返回结果进行后续的思考或生成响应。
*   **返回值**：可以是任何 Python 内置的可序列化类型（如 `str`, `int`, `float`, `bool`, `list`, `dict` 等）。
*   **AI 交互**：AI 调用后，会等待方法执行完毕并获取返回值，然后基于返回值继续执行其任务。

##### 2. `SandboxMethodType.AGENT` (代理方法)

*   **用途**：用于执行需要 AI 进一步处理或解释的操作，或者提供需要 AI 进行迭代思考的信息。
*   **返回值**：**必须是字符串 (`str`) 类型**。
*   **AI 交互**：方法返回的字符串会被添加到当前的对话上下文中，并**立即触发 AI 进行新一轮的思考和回复**。

##### 3. `SandboxMethodType.BEHAVIOR` (行为方法)

*   **用途**：用于执行某些操作或修改系统状态，AI 需要知道操作的结果，但这个结果本身不应该直接触发 AI 的新一轮回复。
*   **返回值**：**必须是字符串 (`str`) 类型**。
*   **AI 交互**：方法返回的字符串会被作为一条系统消息添加到当前的聊天记录中，供 AI 和用户参考。

##### 4. `SandboxMethodType.MULTIMODAL_AGENT` (多模态代理方法)

*   **用途**：与 `AGENT` 类型类似，但专门用于处理和返回多模态内容（如图像、音频等），并需要 AI 对这些多模态内容进行理解和回应。
*   **返回值**：必须是符合特定结构的多模态消息段。
*   **AI 交互**：返回的多模态消息段会被添加到当前的对话上下文中，并**立即触发 AI 进行新一轮的思考和回复**。

#### 编写沙盒方法：规范与最佳实践

为了确保 AI 能够正确、高效地使用你的沙盒方法，请遵循以下规范：

1.  **清晰的函数签名与类型注解**：
    *   所有沙盒方法都必须是异步函数 (`async def`)。
    *   第一个参数**必须**是 `_ctx: AgentCtx`。
    *   为所有参数和返回值添加明确的 Python 类型注解。

2.  **详细且结构化的文档字符串 (Docstring)**：
    *   **简洁的摘要行**：清晰说明方法的功能。
    *   **`Args:` 部分**：列出所有参数（除了 `_ctx`），说明每个参数的名称、类型和含义。
    *   **`Returns:` 部分**：说明返回值的类型和含义。
    *   **`Example:` 部分**：提供一个或多个 AI 可以理解和模仿的 Python 调用示例。

3.  **适当的命名**：
    *   沙盒方法的 `name` 参数应使用清晰、简洁、符合 AI 调用习惯的命名方式。

4.  **错误处理**：
    *   在方法内部妥善处理可能发生的异常。
    *   尽量不要让未捕获的异常直接抛给 AI。

5.  **返回值处理**：
    *   严格遵守所选 `SandboxMethodType` 对返回值的类型要求。

### 插件配置

一个设计良好的插件通常需要提供一些可配置的选项，允许用户根据自己的需求调整插件的行为，或者提供必要的凭证（如 API 密钥）。Nekro Agent 提供了一套强大的插件配置系统，基于 Pydantic 模型，并能自动生成用户友好的 WebUI 管理界面。

#### 注册配置类

插件的配置是通过定义一个继承自 `nekro_agent.api.plugin.ConfigBase` 的类，并使用 `@plugin.mount_config()` 装饰器将其注册到插件实例来实现的。

```python
from nekro_agent.api.plugin import ConfigBase, ExtraField
from pydantic import Field

@plugin.mount_config()
class MyPluginConfig(ConfigBase):
    """我的插件的配置项定义"""

    # API 密钥配置（敏感信息）
    api_key: str = Field(
        default="",
        title="服务 API 密钥",
        description="请输入从第三方服务获取的 API 密钥。这是必需的。",
        json_schema_extra=ExtraField(is_secret=True, required=True).model_dump()
    )

    # 基础数值配置
    max_items: int = Field(
        default=10,
        title="最大处理项目数",
        description="单次操作允许处理的最大项目数量。",
    )
```

#### 定义配置项 (`Field`)

Pydantic 的 `Field` 用于为配置项提供默认值、类型约束、描述以及控制其在 WebUI 中的显示和行为。

**`Field` 的常用参数**：

*   `default`: 配置项的默认值。
*   `title` (str): 在 WebUI 中显示的配置项名称（标签）。
*   `description` (str): 对配置项的详细说明。
*   `json_schema_extra`: 用于传递额外的 WebUI 控制参数。推荐使用 `ExtraField` 模型来生成。

**`ExtraField` 常用属性**：

*   `is_secret` (bool): 敏感信息保护，设置为 `True` 时输入框显示为密码形式
*   `is_hidden` (bool): 配置项可见性控制，设置为 `True` 时在 WebUI 中隐藏
*   `is_textarea` (bool): 多行文本支持
*   `placeholder` (str): 输入提示文本
*   `required` (bool): 必填字段标识
*   `ref_model_groups` (bool): 模型组引用标识
*   `model_type` (str): 模型类型规范，可选值有 `chat`、`embedding`、`draw`
*   `is_need_restart` (bool): 重启需求标识，修改后需要重启应用才能生效

#### 访问配置

一旦配置类被注册，你就可以在插件的任何地方通过 `plugin.config` 属性访问到配置类的实例。

```python
@plugin.mount_sandbox_method(SandboxMethodType.TOOL, "perform_action", "执行一个需要配置的操作。")
async def my_action(ctx: AgentCtx, some_input: str) -> str:
    # 访问配置项
    api_key = plugin.config.api_key
    max_items = plugin.config.max_items

    if not api_key:
        return "错误：API 密钥未配置。请前往插件配置页面进行设置。"

    return f"已使用 API 密钥 '{api_key[:4]}...'，最大项目数为 {max_items}。"
```

### 数据存储

插件开发中经常需要持久化数据，例如用户偏好、会话状态、缓存信息、配置文件、模型文件等。Nekro Agent 为插件提供了两种互补的数据存储方式。

#### 存储方式概览

1. **KV 键值存储 (`plugin.store`)**
   - **存储类型**：数据库支持的键值对存储
   - **数据形式**：字符串类型（需序列化复杂数据）
   - **适用场景**：小型结构化数据、配置项、状态信息
   - **访问方式**：通过 `plugin.store` API 异步访问
   - **数据作用域**：支持会话级、用户级、插件全局三种作用域

2. **插件持久化目录 (`plugin.get_plugin_path()`)**
   - **存储类型**：文件系统目录
   - **数据形式**：任意文件和二进制数据
   - **适用场景**：大文件、二进制数据、模型文件、资源文件
   - **访问方式**：通过 `pathlib.Path` 进行文件系统操作
   - **数据作用域**：插件独占目录，需自行管理子目录结构

#### KV 键值存储核心 API

```python
# 设置数据
await plugin.store.set(
    chat_key=_ctx.from_chat_key,  # 可选
    user_key=_ctx.from_user_id,   # 可选
    store_key="my_key",
    value="my_value"
)

# 获取数据
value = await plugin.store.get(
    chat_key=_ctx.from_chat_key,
    store_key="my_key"
)

# 删除数据
await plugin.store.delete(
    chat_key=_ctx.from_chat_key,
    store_key="my_key"
)
```

#### 插件持久化目录使用

```python
# 获取插件目录
plugin_dir = plugin.get_plugin_path()

# 创建子目录
logs_dir = plugin_dir / "logs"
logs_dir.mkdir(parents=True, exist_ok=True)

# 保存文件
log_file = logs_dir / f"log_{int(time.time())}.txt"
async with aiofiles.open(log_file, "w", encoding="utf-8") as f:
    await f.write(log_content)
```

### 提示词注入

提示词注入 (Prompt Injection) 是 Nekro Agent 插件影响 AI 行为、提供上下文信息或定制其角色的关键机制之一。通过向 AI 的主提示词（System Prompt）中动态添加内容，插件可以引导 AI 的思考方向和响应风格。

#### 注册提示词注入方法

插件通过 `@plugin.mount_prompt_inject_method()` 装饰器注册一个异步函数，该函数负责生成需要注入的提示词内容。

```python
@plugin.mount_prompt_inject_method(
    name="status_awareness_prompt",
    description="向 AI 注入当前会话的状态信息和可用工具提示。"
)
async def inject_status_prompt(_ctx: AgentCtx) -> str:
    """生成并返回需要注入到主提示词中的字符串。"""
    
    current_status = await plugin.store.get(chat_key=_ctx.from_chat_key, store_key="current_channel_status")
    
    prompt_parts = []
    
    if current_status:
        prompt_parts.append(f"当前状态提示：会话状态目前是 '{current_status}'。")
    else:
        prompt_parts.append("当前状态提示：会话状态未知或为默认状态。")

    prompt_parts.append("你可以使用 'get_weather(city)' 工具查询天气。")
    prompt_parts.append("你可以使用 'set_reminder(time_desc,message)' 工具设置提醒。")

    injected_prompt = "\n".join(prompt_parts)
    
    return injected_prompt
```

#### 设计有效的注入提示词

1.  **简洁明了**：注入的内容应尽可能简短、清晰、易于 AI 理解。
2.  **高度相关**：只注入与当前会话、当前用户或插件核心功能紧密相关的信息。
3.  **结构化**：如果注入多条信息，尽量使用一致的格式。
4.  **动态生成**：充分利用 `AgentCtx` 和插件存储中的信息，动态生成与当前情境最匹配的提示词内容。
5.  **明确指示**：如果希望 AI 使用特定工具或遵循特定行为，可以在提示词中给出明确的指示。

### Agent 上下文 (AgentCtx)

`AgentCtx` 是 Nekro Agent 插件开发中最重要的概念之一。它封装了 Agent 在执行任务时所需的所有上下文信息，为插件提供了统一的接口来访问相关数据和功能。

#### 核心属性

```python
# 沙盒和聊天标识
_ctx.from_chat_key: Optional[str]     # 来源聊天的唯一标识
_ctx.chat_key: Optional[str]          # 聊天频道唯一ID
_ctx.container_key: Optional[str]     # 沙盒容器的唯一标识

# 聊天频道信息
_ctx.channel_id: Optional[str]        # 频道的原始平台 ID
_ctx.channel_name: Optional[str]      # 频道名称
_ctx.channel_type: Optional[str]      # 频道类型
_ctx.adapter_key: Optional[str]       # 适配器标识
```

#### 核心功能模块

##### 文件系统 (`fs`)

`_ctx.fs` 提供了强大的文件处理能力，用于在插件和 AI 之间安全地传递文件。

```python
# 插件向 AI 传递文件
sandbox_path = await _ctx.fs.mixed_forward_file(
    file_source,  # 可以是 URL、bytes、Path、BinaryIO
    file_name="file.png"
)

# AI 向插件传递文件
host_path = _ctx.fs.get_file(sandbox_path)  # 将沙盒路径转换为宿主机路径
```

##### 消息模块 (`ms`)

`_ctx.ms` 提供对底层消息模块的直接访问，主要用于需要手动指定 `chat_key` 的高级场景和主动触发 AI 响应。

```python
# 发送文本消息
await _ctx.ms.send_text(chat_key, content, ctx)

# 推送系统消息并触发 AI 响应
await _ctx.ms.push_system(
    chat_key=chat_key,
    message=message,
    ctx=ctx,
    trigger_agent=True  # 是否触发 AI 生成回复
)
```

#### 便捷方法

```python
# 发送文本消息到当前聊天频道
await _ctx.send_text("消息内容", record=True)

# 发送图片到当前聊天频道
await _ctx.send_image(image_path, record=True)

# 发送文件到当前聊天频道
await _ctx.send_file(file_path, record=True)

# 向当前频道推送系统消息
await _ctx.push_system("系统消息", trigger_agent=False)
```

#### 配置访问

```python
# 获取当前生效的核心配置实例
config = await _ctx.get_core_config()
```

#### 特定适配器方法

```python
# 获取 OneBot V11 Bot 实例（仅适用于 OneBot V11 适配器）
if _ctx.adapter_key == "onebot_v11":
    bot = await _ctx.get_onebot_v11_bot()
    await bot.send_private_msg(user_id=user_id, message=message)
```

## 高级功能

在掌握了插件的核心概念之后，本章节将引导你探索 Nekro Agent 插件系统提供的一些高级功能。这些功能可以帮助你构建更强大、更灵活、集成度更高的插件，以应对复杂的应用场景。

### Webhook 接入点（已废弃）

::: danger 功能已废弃
Webhook 功能已被标记为废弃，将在未来版本中移除。请使用新的动态路由功能来实现外部 HTTP 接入点。
:::

### 文件交互

插件开发中经常需要处理文件，例如读取用户上传的文件、生成图片或文档返回给 AI、处理多媒体内容等。Nekro Agent 提供了全新的文件系统 API，通过 `AgentCtx` 的 `fs` 属性，让插件和 AI 沙盒之间的文件传递变得简单高效。

#### 核心概念

- **沙盒路径**: AI 看到的文件路径，通常以 `/app/uploads/` 或 `/app/shared/` 开头
- **宿主机路径**: 插件实际操作的文件在宿主机上的真实路径

#### 插件向 AI 传递文件

```python
# 从 URL 转发图片
image_url = "https://example.com/logo.png"
sandbox_path = await _ctx.fs.mixed_forward_file(image_url, file_name="logo.png")

# 生成数据文件
json_data = json.dumps(data).encode('utf-8')
sandbox_path = await _ctx.fs.mixed_forward_file(json_data, file_name="data.json")

# 使用插件共享目录
temp_file = _ctx.fs.shared_path / "temp.txt"
with open(temp_file, "w") as f:
    f.write(content)
sandbox_path = _ctx.fs.forward_file(temp_file)
```

#### AI 向插件传递文件

```python
# 分析图片文件
host_path = _ctx.fs.get_file(image_path)  # image_path 是 AI 提供的沙盒路径
with Image.open(host_path) as img:
    width, height = img.size

# 处理文本文件
host_path = _ctx.fs.get_file(file_path)
async with aiofiles.open(host_path, "r", encoding="utf-8") as f:
    content = await f.read()
```

#### 结合消息发送的文件处理

```python
# 生成并发送报告
report_content = f"# {title}\n\n{content}"
report_bytes = report_content.encode('utf-8')
sandbox_path = await _ctx.fs.mixed_forward_file(report_bytes, file_name=f"{title}.md")
await _ctx.send_file(sandbox_path)
```

### 使用向量数据库 (Qdrant)

Nekro Agent 集成了 Qdrant 向量数据库，并为插件提供了访问其客户端的便捷方式。这使得插件能够利用向量相似性搜索来实现强大的语义理解、信息检索、内容推荐等功能。

#### 获取 Qdrant 客户端

```python
from nekro_agent.api import core
from qdrant_client import QdrantClient

async def get_qdrant_client():
    qdrant_client = await core.get_qdrant_client()
    if not qdrant_client:
        raise ConnectionError("Qdrant client is not available.")
    return qdrant_client
```

#### 插件专属的集合名称

```python
# 生成一个默认的集合名称，基于插件的作者和模块名
default_collection_name = plugin.get_vector_collection_name()
# 示例输出: "MyAuthor.MyPlugin"

# 为插件内的特定用途生成带有后缀的集合名称
specific_collection_name = plugin.get_vector_collection_name("user_documents")
# 示例输出: "MyAuthor.MyPlugin-documents"
```

#### 初始化时检查和创建集合

```python
async def init_vector_db_collection(plugin_instance, embedding_dimension):
    qdrant_client = await core.get_qdrant_client()
    if not qdrant_client:
        return

    collection_name = plugin_instance.get_vector_collection_name()

    collections_response = await qdrant_client.get_collections()
    existing_collections = [col.name for col in collections_response.collections]

    if collection_name not in existing_collections:
        await qdrant_client.create_collection(
            collection_name=collection_name,
            vectors_config=models.VectorParams(
                size=embedding_dimension,
                distance=models.Distance.COSINE,
            ),
        )
```

#### 生成文本嵌入

```python
async def generate_text_embedding(text_to_embed, plugin_config):
    # 获取模型组配置信息
    model_group_info = core_config.get_model_group_info(plugin_config.EMBEDDING_MODEL_GROUP)
    
    # 调用嵌入模型生成向量
    embedding_vector = await gen_openai_embeddings(
        model=model_group_info.CHAT_MODEL,
        input=text_to_embed,
        api_key=model_group_info.API_KEY,
        base_url=model_group_info.BASE_URL,
        dimensions=plugin_config.EMBEDDING_DIMENSION
    )
    
    return embedding_vector
```

#### 存储数据到 Qdrant

```python
async def store_vector_data(qdrant_client, collection_name, original_data_id, embedding_vector, payload_data):
    # 将原始ID转换为Qdrant Point ID
    qdrant_point_id_hex = hashlib.md5(original_data_id.encode()).hexdigest()[:16]
    qdrant_point_id = int(qdrant_point_id_hex, 16)

    points_to_upsert = [
        models.PointStruct(
            id=qdrant_point_id,
            vector=embedding_vector,
            payload={
                "original_id": original_data_id,
                **payload_data
            }
        )
    ]

    await qdrant_client.upsert(
        collection_name=collection_name,
        points=points_to_upsert,
        wait=True
    )
```

#### 从 Qdrant 搜索数据

```python
async def search_similar_vectors(qdrant_client, collection_name, query_vector, top_k=5, score_threshold=None):
    search_results = await qdrant_client.search(
        collection_name=collection_name,
        query_vector=query_vector,
        limit=top_k,
        score_threshold=score_threshold,
        with_payload=True
    )
    
    return search_results
```

#### 从 Qdrant 删除数据

```python
async def delete_vector_data_by_original_ids(qdrant_client, collection_name, original_ids_to_delete):
    qdrant_point_ids_to_delete = []
    for original_id in original_ids_to_delete:
        qdrant_point_id_hex = hashlib.md5(original_id.encode()).hexdigest()[:16]
        qdrant_point_ids_to_delete.append(int(qdrant_point_id_hex, 16))
    
    await qdrant_client.delete(
        collection_name=collection_name,
        points_selector=models.PointIdsList(points=qdrant_point_ids_to_delete),
        wait=True
    )
```

### 动态路由

动态路由是 Nekro Agent 插件系统提供的强大功能，允许插件创建自定义的 Web API 端点。基于 FastAPI 框架，动态路由支持完整的 RESTful API 设计、请求验证、响应处理、文档生成等现代 Web API 开发的所有特性。

#### 注册路由

```python
from fastapi import APIRouter

@plugin.mount_router()
def create_router() -> APIRouter:
    """创建并配置插件路由"""
    router = APIRouter()

    @router.get("/")
    async def index():
        return {"message": "欢迎使用插件 API"}

    return router
```

#### 完整 CRUD 示例

```python
from typing import Dict, List
from fastapi import APIRouter, HTTPException, Query, Path
from pydantic import BaseModel

class UserModel(BaseModel):
    id: int
    name: str
    email: str

# 模拟数据存储
users_db: Dict[int, UserModel] = {}
next_id = 1

@plugin.mount_router()
def create_router() -> APIRouter:
    router = APIRouter()

    @router.get("/users", response_model=List[UserModel])
    async def get_users(
        limit: int = Query(10, ge=1, le=100),
        offset: int = Query(0, ge=0)
    ):
        """获取用户列表，支持分页"""
        users = list(users_db.values())
        return users[offset:offset + limit]

    @router.post("/users", response_model=UserModel, status_code=201)
    async def create_user(user_data: dict):
        """创建新用户"""
        global next_id
        
        new_user = UserModel(
            id=next_id,
            name=user_data.get("name"),
            email=user_data.get("email")
        )
        
        users_db[next_id] = new_user
        next_id += 1
        
        return new_user

    @router.get("/users/{user_id}", response_model=UserModel)
    async def get_user(user_id: int = Path(..., ge=1)):
        """根据 ID 获取用户详情"""
        if user_id not in users_db:
            raise HTTPException(status_code=404, detail="用户不存在")
        return users_db[user_id]

    @router.put("/users/{user_id}", response_model=UserModel)
    async def update_user(user_id: int, user_data: dict):
        """更新用户信息"""
        if user_id not in users_db:
            raise HTTPException(status_code=404, detail="用户不存在")
        
        user = users_db[user_id]
        if "name" in user_data:
            user.name = user_data["name"]
        if "email" in user_data:
            user.email = user_data["email"]
        
        return user

    @router.delete("/users/{user_id}")
    async def delete_user(user_id: int):
        """删除用户"""
        if user_id not in users_db:
            raise HTTPException(status_code=404, detail="用户不存在")
        
        deleted_user = users_db.pop(user_id)
        return {"message": f"用户 '{deleted_user.name}' 已删除"}

    return router
```

#### 与插件功能集成

```python
from nekro_agent.api import message

@router.post("/notify/{chat_key}")
async def send_notification(chat_key: str, notification: dict):
    """向指定聊天频道发送通知"""
    try:
        ctx = await AgentCtx.create_by_chat_key(chat_key)
        
        await message.send_text(
            chat_key=chat_key,
            text=notification.get("message", ""),
            ctx=ctx
        )
        
        return {"status": "success", "message": "通知已发送"}
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"发送失败: {str(e)}")
```

### 动态包导入

Nekro Agent 提供了动态包导入功能，允许插件在运行时按需安装和导入 Python 第三方包。这个特性让插件能够在不修改系统环境的前提下，灵活地使用各种 Python 生态中的工具库和框架。

#### 基础用法

```python
from nekro_agent.api.plugin import dynamic_import_pkg

@plugin.mount_sandbox_method(SandboxMethodType.TOOL, "use_requests", "使用 requests 库发送 HTTP 请求")
async def fetch_url(_ctx: AgentCtx, url: str) -> str:
    """使用动态导入的 requests 库获取网页内容"""

    # 动态导入 requests 包
    requests = dynamic_import_pkg("requests")

    try:
        response = requests.get(url, timeout=10)
        response.raise_for_status()
        return f"成功获取页面，状态码: {response.status_code}，内容长度: {len(response.text)} 字符"
    except Exception as e:
        return f"请求失败: {e}"
```

#### 版本规范

```python
# 精确版本
pandas = dynamic_import_pkg("pandas==2.0.0")

# 最低版本要求
numpy = dynamic_import_pkg("numpy>=1.24.0")

# 版本范围
requests = dynamic_import_pkg("requests>=2.25.0,<3.0.0")

# 排除特定版本
flask = dynamic_import_pkg("flask>=2.0,!=2.0.1")
```

#### 实用场景示例

```python
# 网页爬取
@plugin.mount_sandbox_method(SandboxMethodType.TOOL, "scrape_webpage", "抓取网页内容")
async def scrape_webpage(_ctx: AgentCtx, url: str, selector: str) -> str:
    """使用 BeautifulSoup 抓取网页指定元素"""

    # 动态导入所需的包
    requests = dynamic_import_pkg("requests>=2.25.0")
    bs4 = dynamic_import_pkg("beautifulsoup4>=4.9.0", import_name="bs4")

    # 获取网页内容
    response = requests.get(url, timeout=10)
    response.raise_for_status()

    # 解析 HTML
    soup = bs4.BeautifulSoup(response.text, 'html.parser')
    elements = soup.select(selector)

    # 提取文本内容
    results = [elem.get_text(strip=True) for elem in elements[:5]]
    return f"找到 {len(elements)} 个元素，前 {len(results)} 个内容：\n" + "\n".join(results)
```

## 系统 API 参考

Nekro Agent 为插件开发者提供了一系列核心系统服务的 API，使得插件能够与 Agent 的核心功能进行深度集成。这些 API 通常通过 `nekro_agent.api` 包下的模块进行访问。

### 核心服务 (`nekro_agent.api.core`)

`core` 模块提供了一些基础和核心的工具及服务。

*   **日志服务 (`core.logger`)**
    *   提供标准的日志记录功能，支持不同级别（如 `debug`, `info`, `warning`, `error`, `success`, `critical`）。
    *   示例: `core.logger.info("插件已启动")`

*   **Qdrant 向量数据库客户端**
    *   `core.get_qdrant_client() -> Optional[QdrantClient]` (async): 获取全局 Qdrant 客户端实例。
    *   `core.get_qdrant_config() -> Optional[dict]` (async): 获取 Qdrant 连接配置。

*   **全局配置访问 (`core.config`)**
    *   可以直接访问 Nekro Agent 的全局配置项（定义在 Agent 主配置文件中）。
    *   示例: `api_base = core.config.NEKRO_API_BASE`

### 消息服务 (`nekro_agent.api.message`)

`message` 模块负责处理消息的发送。

*   **发送文本消息 (`message.send_text`)**
    *   `message.send_text(chat_key: str, text: str, ctx: AgentCtx)` (async)
    *   向指定的 `chat_key` (会话标识) 发送纯文本消息。

*   **发送图片消息 (`message.send_image`)**
    *   `message.send_image(chat_key: str, image_path: str, ctx: AgentCtx)` (async)
    *   `image_path` 可以是图片的 URL (str) 或本地文件路径 (str)。

*   **发送文件消息 (`message.send_file`)**
    *   `message.send_file(chat_key: str, file_path: str, ctx: AgentCtx)` (async)
    *   发送文件。`file_path` 参数同上。

这个 API 参考提供了一个概览。强烈建议插件开发者在实际开发中结合源代码、IDE 工具和具体的示例插件来深入理解和使用这些 API。

---

通过本指南的学习，你应该已经掌握了 Nekro Agent 插件开发的核心概念和高级功能。从创建简单的 "Hello World" 插件，到实现复杂的文件交互、向量数据库集成和动态路由 API，你现在已经具备了开发强大 Nekro Agent 插件的能力。

记住，插件开发是一个持续学习和实践的过程。不断尝试新的功能组合，参考官方示例插件，并积极参与社区交流，你将能够创建出更加出色和创新的插件。

祝你开发愉快！
```

这个合并后的文档包含了所有原始文档的内容，按照逻辑顺序组织，从基础概念到高级功能，最后是系统 API 参考，形成了一个完整的插件开发指南。